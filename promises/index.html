<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">	

	
	<head>
	
        <title>Amy J. Ko, Ph.D. | Promises</title>        
	
		<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
		
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
	
		<style>
			
			.bar {
				display: inline-block;
				height: 3em;
				overflow: hidden;
				margin: 0.1em;
				border-radius: 3px;
			}
			
			.large {
				font-size: x-large;
			}
			
			.row {
				min-height: 4em;
				padding: 0.5em;
			}
			
		</style>
				
	</head>
	
	
	<body>

		
		<div class="container-fluid" id="rows">
		</div>				
				
		<script>

			var profile = {
				// Maximum hours I prefer to work.
				preferredHours: 45,
				// Maximum hours possible to work.
				maxHours: 75,
				// CSS color names by category names.
				colors: {
					"funding": "rgb(120,120,255)",
					"research": "rgb(160,160,255)",
					"reviewing": "rgb(255,210,40)",
					"teaching": "rgb(120,200,120)",
					"service": "orange",
					"travel": "rgb(255,120,120)",
					"personal": "lightGrey"
				},
				ranks: {
					"personal": 0,
					"funding": 1,
					"research": 2,
					"teaching": 3,
					"service": 4,
					"reviewing": 5,
					"travel": 6
				}
			};			
						
			function getPreviousMonday() {
				
			    var date = new Date();
			    var day = date.getDay();
			    var prevMonday;
			    if(date.getDay() === 1) {
			        prevMonday = new Date().setDate(date.getDate() - 7);
			    }
			    else{
			        prevMonday = new Date().setDate(date.getDate() - day + 1);
			    }
			
			    return new Date(prevMonday);

			}
									
			// Takes a list of promises and splits them into per week
			// promises.
			function promisesToWeeks(promises) {
				
				// Start a list of weeks to return.
				var weeks = [];
				
				// Start a date counter with last Monday.
				var currentDate = getPreviousMonday();

				// Iterate through the next 3 years.
				for(var count = 1; count < 52 * 3; count++) {
					
					// Add a new week.
					var weeksPromises = [];
					
					var nextDate = new Date(currentDate.getTime() + 7 * 24 * 60 * 60 * 1000);					
					
					// Which promises occur in this week?
					_.forEach(promises, function(promise) {
						
						var start = new Date(promise.start);
						var end = promise.end === "" ? null : new Date(promise.end);
						
						// If the start of the promise is within this week OR
						// The promise starts before and ends after ||
						// The promise started earlier and has no end OR
						// The end of the promise is within this week
						if(	(start.getTime() >= currentDate.getTime() && start.getTime() <= nextDate.getTime()) ||
							(end !== null && start.getTime() <= currentDate.getTime() && end.getTime() >= nextDate.getTime()) ||
							(start.getTime() < currentDate.getTime() && end === null) ||
							(end !== null && end.getTime() >= currentDate.getTime() && end.getTime() <= nextDate.getTime())) {
						
							var proportionOfWeek = Math.min(1,
								end === null ? 
									1 : 
									start.getTime() < currentDate.getTime() ? 
										(end.getTime() - currentDate.getTime()) / 1000 / 60 / 60 / 24 / 7 :
										(nextDate.getTime() - start.getTime()) / 1000 / 60 / 60/ 24 / 7);
						
							weeksPromises.push(
								{
									description: promise.description,
									hours: Math.round(promise.weeklyHours * proportionOfWeek),
									category: promise.category,
									strength: promise.strength,
									rank: profile.ranks[promise.category],
								}
							);									
								
						}
						
					});
					
					// Are there any suppressing promises?
					if(_.includes(_.map(weeksPromises, "strength"), 1))
						_.remove(weeksPromises, function(promise) { return promise.strength < 0; });
					
					// Sort the remaining promises by rank.
					weeksPromises = _.sortBy(weeksPromises, "rank");

					// Add this week.
					weeks.push({
						start: currentDate,	
						promises: weeksPromises
					});

					// Add a week to the date.					
					currentDate = nextDate;
					
				}
				
				// Iterate through the promises and generate a list of 
				// promises by week.
				return weeks;
				
			}
			
			// Takes a list of promises according to a week and
			// converts them into Bootstrap rows for rendering.
			function weeksToRows(weeks, profile) {
				
				var rows = [];
				var lastYear = null;
				var lastMonth = null;
				
				for(var i = 0; i < weeks.length; i++) {
					var week = weeks[i];
					var date = new Date(week.start);
					var nextYear = date.getFullYear();
					var nextMonth = date.getMonth();
					rows.push(renderRow(week, profile, lastMonth !== nextMonth, lastYear !== nextYear));
					lastYear = nextYear;
					lastMonth = nextMonth;
				}
				
				return rows;
								
			}
	
			function renderMonth(date) {
				
				return [
					"1/",
					"2/",
					"3/",
					"4/",
					"5/",
					"6/",
					"7/",
					"8/",
					"9/",
					"10/",
					"11/",
					"12/"
				][date];

				
			}
	
			// Takes a promise and renders a row
			function renderRow(week, profile, showMonth, showYear) {
				
				var date = new Date(week.start);
				var month = renderMonth(date.getMonth());
				var year = date.getFullYear() - 2000;
				
				// Convert all of this week's promises into a series of bars.
				var bars = _.map(
					week.promises, 
					function(promise) { 
						return renderBar(
							promise.hours / profile.maxHours, 
							profile.colors[promise.category]
						);
					}
				).join("");

				// Convert this week's promises into a list of promises.
				var descriptions = _.map(
					week.promises, 
					function(promise) { 
						return "<span style='color:" + profile.colors[promise.category] + "'>" + promise.description + "</span>";
					}
				).join(", ");
				
				var totalHours = _.reduce(
					_.map(week.promises, "hours"),
					function(sum, n) { return sum + n; }
				);
				
				var backgroundColor = 
					totalHours < profile.preferredHours ?
						255 :
						Math.max(200, Math.round(255 - 55.0 * ((totalHours - profile.preferredHours) / (profile.maxHours - profile.preferredHours))));

				return '<div class="row" style="background-color: rgb(255, ' + backgroundColor + ',' + backgroundColor + ')">' +
						'<div class="col-1">' + 
							(
								showMonth ? ("<span class='large'>'" + year + "</br>" + month + date.getDate() + "</span>") :
								date.getDate()								
							) +
						"</div>" +
						'<div class="col-9">' + bars + '</br>' + descriptions + '</div>' +
						'<div class="col-1 large">' + totalHours + '</div>' +
					'</div>'
					;
				
			}
			
			// Returns a bar
			function renderBar(percent, color) {
				
				return '<div class="bar" style="width:' + 
					Math.round(100 * percent) + 
					'%; background-color:' + color + '"></div>';
				
			}
			
			function parseCSV(text) {
				
				return _.map(text.split("\n"), function(promise) {
					promise = promise.split(",");
					return {
						description: promise[0].trim(),
						category: promise[1].trim(),
						start: promise[2].trim(),
						end: promise[3].trim(),
						weeklyHours: parseInt(promise[4].trim()),
						strength: parseInt(promise[5].trim()),
					}
				});
				
			}

			var xhr = new XMLHttpRequest();
			xhr.open('GET', 'promises.csv');
			xhr.onload = function() {
			    if (xhr.status === 200) {
			        // Render everything.
					document.getElementById("rows").innerHTML = weeksToRows(promisesToWeeks(parseCSV(xhr.responseText)), profile).join("");
			    }
			    else {
			        document.getElementById("rows").innerHTML = "Couldn't load";
			    }
			};
			xhr.send();



			
		</script>
		
	</body>
	
	
</html>